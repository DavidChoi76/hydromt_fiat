import pandas as pd
import numpy as np
from pathlib import Path
from hydromt.data_catalog import DataCatalog
import re

### TO BE UPDATED ###
class Vulnerability:
    def __init__(self, data_catalog: DataCatalog):
        self.data_catalog = data_catalog

    def get_vulnerability_function(self, vulnerability_source, vulnerability_identifiers_and_linking):
        # TODO: @Luis: this function needs to be changed. Now it looks up a damage function
        # according to country that is chosen but we want the user to choose their
        # damage functions per category (res, com, etc.). So our function will be
        # quite different.
        """Return the susceptibility function id and the maximum damage number."""

        # Save the source vulnerabilities and input vulnerability identifiers and linking as data frames.
        df_source = self.data_catalog.get_dataframe(vulnerability_source)

        # USER INPUT, read csv generated via gui or manually inputted
        df_identifiers_linking = pd.read_csv(vulnerability_identifiers_and_linking)
        
        # Identify the unique combinations of values from the identifiers and linking data frame that will be used to select subsets of values from the source data frame.
        # unique_combinations = df_identifiers_linking.groupby(['ID', 'Occupancy', 'Source', 'Description']).nunique().reset_index()

        # Initialize an empty list to hold the subsets
        subsets = []

        # Loop over the unique combinations of values
        for i in range(len(df_identifiers_linking)):
            # Use the unique combination of values to select the corresponding subset of values
            # from the first data frame using boolean indexing
            subset = df_source.loc[(df_source['BldgDmgFnID'] == df_identifiers_linking.loc[i, 'ID']) &
                            (df_source['Occupancy'] == df_identifiers_linking.loc[i, 'Occupancy']) &
                            (df_source['Source'] == df_identifiers_linking.loc[i, 'Source']) &
                            (df_source['Description'] == df_identifiers_linking.loc[i, 'Description'])]
            
            # # Check if the subset is empty
            # if subset.empty:
            #     print(f"No values found for unique combination {df_identifiers_linking.loc[i]}")
            # else:
            #     print(f"Values found for unique combination {df_identifiers_linking.loc[i]}")
        
            # Append the subset of values to the list of subsets
            subsets.append(subset)

        # Concatenate all of the necessary vulnerability curves info into a single data frame using pd.concat()
        combined_df = pd.concat(subsets, ignore_index=True)

        # Get vulnerability factors and apply FIAT format.
        vf_values_only = combined_df.values.T[4:-1] /100
        
        vf_water_depths_numbers = np.arange(-4,25)
        vf_water_depths = np.array(vf_water_depths_numbers.reshape(-1,1))
        vf_raw = np.hstack([vf_water_depths,vf_values_only])
        
        top_header_array = np.full((1, vf_names_header.shape[0]), fill_value="", dtype='<U100')
        top_header_array[0, 0] = "#UNIT=feet"
        
        vf_names = df_identifiers_linking['Name'].values
        vf_names_header = np.append('water depth', vf_names).reshape(top_header_array.shape)

        vf_fiat_format = np.concatenate([top_header_array, vf_names_header, vf_raw])

        # Create a dataframe out of the previous array.
        v_dataframe = pd.DataFrame(vf_fiat_format)
        
        # Export the dataframe to a csv.
        v_dataframe.to_csv('vulnerability_test_file_output.csv', index=False, header=False)
        