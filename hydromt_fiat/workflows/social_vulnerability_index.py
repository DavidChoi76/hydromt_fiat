from census import Census
from us import states
import pandas as pd


class SocialVulnerabilityIndex:

    def get_svi_data(self,c_key):
        c = Census(c_key)
        census    = c.acs.state_county_blockgroup(fields = ('NAME','B01001_027E', 'B01001_003E', 'B01001_001E' ), state_fips = states.SC.fips, county_fips="*", tract = "*", blockgroup = "*")
        df_census = pd.DataFrame(census)
        df_census.rename(columns={"B01001_027E": "FiveYearsAgeFemBG", "B01001_003E": "FiveYearsAgeMaleBG", "B01001_001E" : "TotalPopulationBG"}, inplace=True)
        return df_census


    def preprocessing_svi_data(self):
        pass


    def normalization_svi_data(self, df):
        #These vairables can be provided as parameters and stablished in the .ini file or through a GUI
        vulnerability_features = ["FiveYearsAgeFemBG", "FiveYearsAgeMaleBG", "TotalPopulationBG"]
        direction              = ['normal', 'normal', 'inverse']

        census_Data      = df.copy()
        svi_fiat         = pd.DataFrame()
        svi_fiat['NAME'] = census_Data['NAME']
        svi_fiat_names   = []

        for column, dir in zip(vulnerability_features, direction):
            if dir == 'normal':
                svi_fiat[column+ '_norm'] = self.minmax_normalize(df[column])
                svi_fiat_names.append(column + '_norm')
            if dir == 'inverse':
                #svi[column+'_score']       = zscore(svi[column])
                svi_fiat[column+ '_norm'] = self.maxmin_normalize(df[column]).multiply(-1)
                svi_fiat_names.append(column + '_norm')
            else:
                print('Direction is not provided')   
        return svi_fiat
    
    def scores_by_cathegory(self, df_normalized):

        #These vairables can be provided as parameters and stablished in the .ini file or through a GUI. 
        #All the variable should be defined normalization_svi_data()
        dict_var        = ['FiveYearsAgeFemBG_norm','FiveYearsAgeMaleBG_norm']
        scores_vars     = [0.5,0.5]
        group_name      = 'age'

        dict_var_II     = ["TotalPopulationBG_norm"]
        scores_vars_II  = [1]
        group_name_II   = 'age_II'

        dict_var_III     = ['FiveYearsAgeFemBG_norm','FiveYearsAgeMaleBG_norm',"TotalPopulationBG_norm"]
        scores_vars_III  = False #If not provided they will provide equal weight.
        group_name_III   = 'age_III'


        def ranking(df, group_name, dict_var, scores_vars):
            if not scores_vars:
                scores_vars = [1/len(dict_var)]*len(dict_var)

            df[group_name] = 0
            for column, factor in zip(dict_var, scores_vars):
                df[group_name] = df[group_name] + df[column]*factor


        ranking(df_normalized,group_name, dict_var, scores_vars)
        ranking(df_normalized,group_name_II, dict_var_II, scores_vars_II)
        ranking(df_normalized,group_name_III, dict_var_III, scores_vars_III)

        return df_normalized



    #General functions used in SocialVulnerabilityIndex()
    def zscore(self, column):
        return (column - column.mean()) / column.std()

    def minmax_normalize(self, column):
        return (column - column.min()) / (column.max() - column.min())

    def maxmin_normalize(self, column):
        return (column - column.max()) / (column.max() - column.min())



